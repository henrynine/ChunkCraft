### Starting build.
# Target: test.mli.depends, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), extension:mli, file:test.mli, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -modules test.mli > test.mli.depends
# Target: test.cmi, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), byte, compile, extension:mli, file:test.mli, interf, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -o test.cmi test.mli
# Target: test.ml.depends, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), extension:ml, file:test.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -modules test.ml > test.ml.depends
# Target: blocks.mli.depends, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), extension:mli, file:blocks.mli, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -modules blocks.mli > blocks.mli.depends
# Target: items.mli.depends, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), extension:mli, file:items.mli, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -modules items.mli > items.mli.depends
# Target: items.cmi, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), byte, compile, extension:mli, file:items.mli, interf, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -o items.cmi items.mli
# Target: state.mli.depends, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), extension:mli, file:state.mli, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -modules state.mli > state.mli.depends
# Target: blocks.cmi, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), byte, compile, extension:mli, file:blocks.mli, interf, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -o blocks.cmi blocks.mli
# Target: state.cmi, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), byte, compile, extension:mli, file:state.mli, interf, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -o state.cmi state.mli
# Target: test.cmo, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), byte, compile, extension:cmo, extension:ml, file:test.cmo, file:test.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -o test.cmo test.ml
# Target: blocks.ml.depends, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), extension:ml, file:blocks.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -modules blocks.ml > blocks.ml.depends
# Target: items.ml.depends, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), extension:ml, file:items.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -modules items.ml > items.ml.depends
# Target: state.ml.depends, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), extension:ml, file:state.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -modules state.ml > state.ml.depends
# Target: blocks.cmo, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), byte, compile, extension:cmo, extension:ml, file:blocks.cmo, file:blocks.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -o blocks.cmo blocks.ml
# Target: items.cmo, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), byte, compile, extension:cmo, extension:ml, file:items.cmo, file:items.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -o items.cmo items.ml
# Target: state.cmo, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), byte, compile, extension:cmo, extension:ml, file:state.cmo, file:state.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -o state.cmo state.ml
+ ocamlfind ocamlc -c -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect -o state.cmo state.ml
File "state.ml", line 190, characters 10-11:
Warning 11: this match case is unused.
# Target: test.byte, tags: { package(ANSITerminal), package(OUnit), package(bisect), syntax(camlp4o,bisect_pp), byte, dont_link_with, extension:byte, file:test.byte, link, ocaml, program, quiet, traverse }
ocamlfind ocamlc -linkpkg -package ANSITerminal -package OUnit -syntax camlp4o,bisect_pp -package bisect items.cmo blocks.cmo state.cmo test.cmo -o test.byte
# Compilation successful.
